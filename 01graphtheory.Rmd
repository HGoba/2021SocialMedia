Untitled
20 传媒大数据 李星照
2021/10/19
图论 一、历史背景 很少有研究领域可以追溯到它们诞生在历史上的那个时刻和地点，但是网络科学背后的数学支架——图论可以。它的起源可以追溯到1735年，在东普鲁士的首都科尼士堡，这是当时一个繁荣的商业城市。在繁忙的船队的支持下，市政官员得以在围绕小镇的普雷格尔河上修建了七座桥。其中五个与大陆相连的是优雅的克奈福夫岛，夹在普雷格尔河的两个分支之间。剩下的两个部分都穿过了河流的两个支流（如下图所示）。 这种特殊的安排产生了一个当代的谜题：一个人能穿过所有七座桥而不会穿过同一座桥吗？即七桥问题。尽管尝试了很多次，但还是没有人能找到这样的路。这个问题一直没有解决，直到1735年，瑞士出生的数学家伦纳德·欧拉提供了一个严格的数学证明，证明这种路径不存在。

欧拉用字母A、B、C和D表示被河流分隔的四个土地区域（图c）。接下来，他把每一块之间有一座桥的土地连接起来。因此，他建立了一个图表，其中的节点是土地的碎片，连接部分是桥梁。然后欧拉做了一个简单的观察：如果有一条路径穿过所有的桥，但永远不是同一座桥两次，那么具有奇数链接的节点必须是这条路径的起点或终点。实际上，如果你到达一个带有奇数链接的节点，你可能会发现自己没有未使用的链接可以离开它。 一条穿过所有桥梁的步行道只有一个起点和一个终点。因此，这样的路径不能存在于具有两个以上的奇数链接节点的图上。柯尼斯伯格图有四个具有奇数链接的节点a、B、C和D，所以没有一条路径不能满足这个问题。 欧拉的证明是第一次有人用图来解决数学问题。对我们来说，证明有两个重要的信息：第一个是，如果一些问题作为图，就会变得更简单、更易于处理。第二，路径的存在，柯尼斯堡的桥梁不依靠我们的独创性来找到它。相反，它是图的一个属性。事实上，考虑到柯尼斯伯格图的结构，无论我们多么聪明，我们都永远无法找到我们想要的路径。换句话说，网络在其结构中具有编码的属性，这限制或增强了它们的行为。

二、基本名词

（1） 图论〔Graph Theory〕是应用数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。图论是一种表示 “多对多” 的关系。 （2）图是由顶点和边组成的：(可以无边，但至少包含一个顶点) 一组顶点：通常用 V(vertex) 表示顶点集合 一组边：通常用 E(edge) 表示边的集合 （3）图可以分为有向图和无向图，在图中： (v, w) 表示无向边，即 v 和 w 是互通的 <v, w> 表示有向边，该边始于 v，终于 w （4）图可以分为有权图和无权图： 有权图：每条边具有一定的权重(weight)，通常是一个数字 无权图：每条边均没有权重，也可以理解为权为 1 （5）图又可以分为连通图和非连通图： 连通图：所有的点都有路径相连 非连通图：存在某两个点没有路径相连 （6）图中的顶点有度的概念： 度(Degree)：所有与它连接点的个数之和 入度(Indegree)：存在于有向图中，所有接入该点的边数之和 出度(Outdegree)：存在于有向图中，所有接出该点的边数之和 三、图的表示： 1. 邻接矩阵： 在 n 个顶点的图需要有一个 n × n 大小的矩阵 在一个无权图中，矩阵坐标中每个位置值为 1 代表两个点是相连的，0 表示两点是不相连的，在一个有权图中，矩阵坐标中每个位置值代表该两点之间的权重，0 表示该两点不相连，在无向图中，邻接矩阵关于对角线相等 2. 邻接链表： 对于每个点，存储着一个链表，用来指向所有与该点直接相连的点，对于有权图来说，链表中元素值对应着权重 图1 无向无权图

图2 无向有权图

四、算法 （1）最短路径算法 无权图： 问题：在图中找到某一个顶点到其它所有点的距离 对于初始点 v 来说，某个点的 d 代表该点到初始点的距离。 基本步骤： 1.将所有点的距离 d 设为无穷大 2.挑选初始点 s，将 ds 设为 0，将 shortest 设为 0 3.找到所有距离为 d 为 shortest 的点，查找他们的邻接链表的下一个顶点 w，如果 dw 的值为无穷大，则将 dw 设为 shortest + 1 4.增加 shortest 的值，重复步骤 3，直到没有顶点的距离值为无穷大

（2）最小生成树 例题：搜索下图最小生成树，并计算出权重

knitr::opts_chunk$set(echo = TRUE)
library(hash)#需要用到hash包
## Warning: 程辑包'hash'是用R版本4.1.1 来建造的
## hash-2.2.6.1 provided by Decision Patterns
Nodes<-c("A","B","C","D","E","F","G")
#创建存放顶点的向量
edges<- data.frame(start=character(),end=character(),length=numeric(),stringsAsFactors = F)
edges[1,]<-c("A", "B", 4)
edges[10,]<-c("A", "G", 28)
edges[6,]<-c("A", "C", 15)
edges[3,]<-c("A", "E", 7)
edges[4,]<-c("B", "C", 9)
edges[2,]<-c("C", "E", 5)
edges[9,]<-c("C", "D", 25)
edges[12,]<-c("D", "E", 32)
edges[5,]<-c("D", "G", 12)
edges[7,]<-c("D", "F", 16)
edges[11,]<-c("E","G",30)
edges[8,]<-c("F","G",20)
#创建一个edges数据框存放边
edges[,3]<-as.numeric(edges[,3])
ori_trees<-hash()
#创建空哈希,顶点为键——值
for (i in Nodes){
  .set(ori_trees, keys = i, values = i)
}
#将顶点存入哈希中
find_nodes<-function(x){
  if(ori_trees[[x]]!=x){#双亲节点和当前节点不一致，说明这条边添加了minmum spanning tree
    ori_trees[[x]]<-find_nodes(ori_trees[[x]])
    #找到双亲节点未变化的点
    return(ori_trees[[x]])
  }
  else{
    return(x)
  }
}

minimum_spanning_tree<-data.frame(start=character(),end=character(),leng=numeric(),stringsAsFactors = F)
#定义最小生成树
n<-length(Nodes)-1
#定义循环次数，n为需要添加的边数=顶点数-1
s<-0
for(i in 1:dim(edges)[1]){
  if(s==n){
    break
  }
  if(find_nodes(edges[i,1])!=find_nodes(edges[i,2])){
    #双亲节点不一致
    ori_trees[[find_nodes(edges[i,2])]]<-find_nodes(edges[i,1])#改变该顶点的双亲节点
    minimum_spanning_tree<-rbind(minimum_spanning_tree,edges[i,])#将符合条件的边
  s<-s+1
  }
 
}
五、总结 （1）最短路径算法优缺点： 优点：算法简明、能得到最优解 缺点：效率低（特别是有时候不需要最优解）、运算中占用空间大 （2）最小生成树算法： 一个图的生成树不是唯一的，不同的搜索方法最后的生成树不同，即使是同一种搜索方法，不同的出发点最后的生成树也不同。

六、参考文献 【1】Albert-Laszlo Barabasi - Network Science 【2】Networks An introduction
